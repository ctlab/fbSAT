MODULE CONTROL(REQ, c1Home, c1End, c2Home, c2End, vcHome, vcEnd, pp1, pp2, pp3, vac)
VAR
	c1Extend: boolean;
	c2Extend: boolean;
	c1Retract: boolean;
	c2Retract: boolean;
	vcExtend: boolean;
	vacuum_on: boolean;
	vacuum_off: boolean;

	state: {GoDown, Wait, Piece1, Piece2, Piece3, Vacuum_On, GoUp, VacuumOff, Retract};
	algo: {extendvc, Wait, extend1, extend2, extend1and2, TurnOnVac, Retractvc, TurnOffvac, RetracAll, eps};

	CNF: boolean;
DEFINE
	guard_GoUp_Wait := state = GoUp & REQ & vcHome & c1Home & c2Home;
	guard_Retract_GoDown := state = Retract & REQ & vac & c1Home & c2Home;
	guard_Wait_Piece1 := state = Wait & REQ & pp1 & vcHome;
	guard_Wait_Piece2 := state = Wait & REQ & !pp1 & pp2 & vcHome;
	guard_Wait_Piece3 := state = Wait & REQ & !pp1 & !pp2 & pp3 & vcHome;
	guard_Piece1_GoDown := state = Piece1 & REQ & c1End;
	guard_Piece2_GoDown := state = Piece2 & REQ & c2End;
	guard_Piece3_GoDown := state = Piece3 & REQ & c1End & c2End;
	guard_GoDown_Vacuum_On := state = GoDown & REQ & vcEnd & !(c1Home & c2Home);
	guard_Vacuum_On_GoUp := state = Vacuum_On & REQ & vac;
	guard_VacuumOff_GoUp := state = VacuumOff & REQ & !vac;
	guard_GoDown_VacuumOff := state = GoDown & REQ & vcEnd & c1Home & c2Home;
	guard_GoUp_Retract := state = GoUp & REQ & vcHome & (!c1Home | !c2Home);

ASSIGN
	init(state) := Wait;
	next(state) := case
		guard_GoUp_Wait : Wait;
		guard_Retract_GoDown : GoDown;
		guard_Wait_Piece1 : Piece1;
		guard_Wait_Piece2 : Piece2;
		guard_Wait_Piece3 : Piece3;
		guard_Piece1_GoDown : GoDown;
		guard_Piece2_GoDown : GoDown;
		guard_Piece3_GoDown : GoDown;
		guard_GoDown_Vacuum_On : Vacuum_On;
		guard_Vacuum_On_GoUp : GoUp;
		guard_VacuumOff_GoUp : GoUp;
		guard_GoDown_VacuumOff : VacuumOff;
		guard_GoUp_Retract : Retract;
		TRUE: state;
	esac;

	algo := case
		guard_GoUp_Wait : Wait;
		guard_Retract_GoDown : extendvc;
		guard_Wait_Piece1 : extend1;
		guard_Wait_Piece2 : extend2;
		guard_Wait_Piece3 : extend1and2;
		guard_Piece1_GoDown : extendvc;
		guard_Piece2_GoDown : extendvc;
		guard_Piece3_GoDown : extendvc;
		guard_GoDown_Vacuum_On : TurnOnVac;
		guard_Vacuum_On_GoUp : Retractvc;
		guard_VacuumOff_GoUp : Retractvc;
		guard_GoDown_VacuumOff : TurnOffvac;
		guard_GoUp_Retract : RetracAll;
		TRUE: eps;
	esac;

	init(CNF) := FALSE;
	next(CNF) := case
		algo = extendvc: TRUE;
		algo = Wait: TRUE;
		algo = extend1: TRUE;
		algo = extend2: TRUE;
		algo = extend1and2: TRUE;
		algo = TurnOnVac: TRUE;
		algo = Retractvc: TRUE;
		algo = TurnOffvac: TRUE;
		algo = RetracAll: TRUE;
		TRUE: FALSE;
	esac;
	
	init(c1Extend) := FALSE;
	init(c2Extend) := FALSE;
	init(c1Retract) := FALSE;
	init(c2Retract) := FALSE;
	init(vcExtend) := FALSE;
	init(vacuum_on) := FALSE;
	init(vacuum_off) := FALSE;

	next(c1Extend) := case
		algo = extend1: TRUE;
		algo = extend1and2: TRUE;
		algo = RetracAll: FALSE;
		algo = Wait: FALSE;
		TRUE: c1Extend;
	esac;
	next(c2Extend) := case
		algo = extend2: TRUE;
		algo = extend1and2: TRUE;
		algo = RetracAll: FALSE;
		algo = Wait: FALSE;
		TRUE: c2Extend;
	esac;
	next(c1Retract) := case
		algo = RetracAll: TRUE;
		algo = Wait: FALSE;
		TRUE: c1Retract;
	esac;
	next(c2Retract) := case
		algo = RetracAll: TRUE;
		algo = Wait: FALSE;
		TRUE: c2Retract;
	esac;
	next(vcExtend) := case
		algo = extendvc: TRUE;
		algo = Retractvc: FALSE;
		algo = Wait: FALSE;
		TRUE: vcExtend;
	esac;
	next(vacuum_on) := case
		algo = TurnOnVac: TRUE;
		algo = TurnOffvac: FALSE;
		algo = Wait: FALSE;
		TRUE: vacuum_on;
	esac;
	next(vacuum_off) := case
		algo = TurnOnVac: FALSE;
		algo = TurnOffvac: TRUE;
		algo = Wait: FALSE;
		TRUE: vacuum_off;
	esac;
